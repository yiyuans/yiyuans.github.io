[{"title":"hexo搭建","path":"/2023/07/29/hexo搭建/","content":"生成静态网站命令 1hexo g 生成好的public文件夹就直接当成静态网站进行部署 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 ** _config.yml: 博客的配置文件** 构建 -&gt; 用于生成博客的html文件1hexo g 预览 -&gt; 用于在本地预览博客，打开浏览器，输入 localhost:4000&#x2F; 即可查看。 hexo s 检查博客格式等符合要求后，用此命令将博客推送到远端。(需要是自己的才行)hexo d 实操构建并查阅hexo g &amp;&amp; hexo s 推送（记得清除缓存！！！）hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 问题 can not read a block mapping entry; a multiline key may not be an implicit k 出现问题原因是头部缺少空格，解决方案很简单，只需在 title： date： tags：，后面加上一个空格，然后进行信息输入即可 部署 安装 1234567npm install -g hexo-cli# 初始化一下hexohexo init mybloghexo i# 进入这个myblog文件夹cd myblog npm install 需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub 1npm install hexo-deployer-git --save 将hexo部署到GitHub 12345678deploy: type: git repo: https://github.com/yiyuans/yiyuans.github.io.git branch: masterhexo cleanhexo generatehexo deploy 踩坑 No layout https://blog.csdn.net/Calvin_zhou/article/details/108754264 可能原因： 插件 ：插件名字不对应，_config.yml中的theme，要和主文件夹中themes文件夹对应 主题 markdown文件 查看npm安装hexo插件的情况 1&gt;npm ls --depth 0","tags":["hexo"],"categories":["博客搭建"]},{"title":"node博客","path":"/2023/07/29/node环境搭建/","content":"创建步骤 因可能用到npm的包，因此创建package.json npm init -y 建立bin文件(可执行文件)，下面创建www.js，作为最开始执行的文件 bin&#x2F;www.js 中主要放置服务器相关代码 在根目录下创建app.js，作为业务代码 将package.json中的入口文件main修改为 &quot;main&quot;: &quot;bin/www.js&quot; 安装 nodemon npm install nodemon -D 修改npm config, 指向淘宝npm镜像 1234npm config set registry https://registry.npm.taobao.org # 官方镜像npm set registry https://registry.npmjs.org/npm info underscore （如果上面配置正确这个命令会有字符串response） npm删除包 1npm uninstall nodemon 把package.json中的scripts做修改 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon bin/www.js&quot; &#125; nodemon 可以在服务端代码发生改变时，重新执行最新的代码 12# 运行dev npm run dev 过程代码123456789101112// app.jsconst serverHandler = (req,res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;,&#x27;application/json&#x27;) const responseData = &#123; name : &#x27;bing&#x27;, age : &#x27;18&#x27; &#125; res.end( JSON.stringify(responseData) )&#125;module.exports = serverHandler 12345678910// bin/www.js// 创建服务器const http = require(&#x27;http&#x27;)const serverHandler = require(&#x27;../app&#x27;)const PORT = 5000const server = http.createServer(serverHandler)server.listen(PORT, () =&gt; &#123; console.log(&#x27;server running at port 5000&#x27;);&#125;) createServer讲解在Node.js中，createServer是一个核心模块http提供的函数，用于创建一个HTTP服务器。它的基本语法如下： 1http.createServer([options], [requestListener]) options是一个可选的参数对象，用于配置服务器的一些选项，比如可以指定服务器的主机名、端口号等。 requestListener是一个回调函数，用于处理每个客户端请求的逻辑。它接收两个参数：request和response。 request是一个表示客户端请求的可读流，它提供了与请求相关的信息，比如请求的URL、HTTP头部、请求体等。你可以通过监听request的事件（比如data事件）来读取请求的数据，或者通过调用request的方法（比如request.on(&#39;data&#39;, callback)来监听请求数据的传输过程。 response是一个表示服务器响应的可写流，你可以通过写入数据到response来发送响应给客户端。你可以设置响应头部信息、写入响应正文，或者通过调用response的方法（比如response.write()、response.end()）来完成响应的发送。 createServer函数返回一个http.Server对象，它是一个事件发射器，你可以通过监听它的事件（比如request、connection等）来处理客户端请求或其他与服务器相关的事件。 下面是一个简单的示例，展示如何使用createServer创建一个简单的HTTP服务器： 12345678910const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;); res.end(&#x27;Hello, World!&#x27;);&#125;);server.listen(3000, &#x27;127.0.0.1&#x27;, () =&gt; &#123; console.log(&#x27;Server is running at http://127.0.0.1:3000&#x27;);&#125;); 以上代码创建了一个服务器，监听127.0.0.1的3000端口。当有客户端请求时，服务器会返回一个200状态码和Hello, World!的响应内容。每当有新的请求进来时，会触发request事件，执行回调函数中的逻辑。 初始化路由 主要逻辑：通过 handleBlogRoute(req,res) 将请求传入 blog.js 进行处理 12345678910111213141516171819202122232425// app.jsconst handleBlogRoute = require(&#x27;./src/routes/blog&#x27;)const serverHandler = (req,res) =&gt; &#123; // 设置响应格式 res.setHeader(&#x27;Content-Type&#x27;,&#x27;application/json&#x27;) const url = req.url // 将path挂在req对象上，方便访问 req.path = url.split(&#x27;?&#x27;)[0] const blogData = handleBlogRoute(req,res) if (blogData)&#123; // 结束请求 返回响应 res.end( JSON.stringify(blogData) ) return; &#125; // 若没有命中blog的路由 // 设置状态码，覆盖返回类型 res.writeHead(404,&#123;&#x27;Content-Type&#x27;:&#x27;text/plain&#x27;&#125;) res.write(&#x27;404 Not Found&#x27;) res.end()&#125;module.exports = serverHandler 12345678910111213141516171819202122232425262728293031323334// blog.js// 处理博客相关路由const handleBlogRoute = (req, res) =&gt; &#123; // 定义处理路由的逻辑 const method = req.method if (method === &#x27;GET&#x27; &amp;&amp; req.path === &#x27;/api/blog/list&#x27;) &#123; return &#123; message: &#x27;获取博客列表的接口&#x27; &#125; &#125; if (method === &#x27;GET&#x27; &amp;&amp; req.path === &#x27;/api/blog/detail&#x27;) &#123; return &#123; message: &#x27; 获取博客详情的接口&#x27; &#125; &#125; if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/new&#x27;) &#123; return &#123; message: &#x27; 新建博客的接口&#x27; &#125; &#125; if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/update&#x27;) &#123; return &#123; message: &#x27; 更新博客的接口&#x27; &#125; &#125; if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/delete&#x27;) &#123; return &#123; message: &#x27; 删除博客列表的接口&#x27; &#125; &#125;&#125;module.exports = handleBlogRoute 开发第一个路由 src controllers blog.js model responseModel.js routes blog.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// routes/blog.js// 处理博客相关路由const &#123;SuccessModel&#125; = require(&#x27;../model/responseModel&#x27;)const &#123;getList&#125; = require(&#x27;../controllers/blog&#x27;)const handleBlogRoute = (req, res) =&gt; &#123; // 定义处理路由的逻辑 const method = req.method if (method === &#x27;GET&#x27; &amp;&amp; req.path === &#x27;/api/blog/list&#x27;) &#123; // /api/blog/list?author=zhangsan&amp;keyword=123 // new SuccessModel() const author = req.query.author || &#x27;&#x27; // 获取不到时为 &#x27;&#x27; const keyword = req.query.keyword || &#x27;&#x27; const listData = getList(author,keyword) return new SuccessModel(listData) // return &#123; // message: &#x27;获取博客列表的接口&#x27; // &#125; &#125; if (method === &#x27;GET&#x27; &amp;&amp; req.path === &#x27;/api/blog/detail&#x27;) &#123; return &#123; message: &#x27; 获取博客详情的接口&#x27; &#125; &#125; if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/new&#x27;) &#123; return &#123; message: &#x27; 新建博客的接口&#x27; &#125; &#125; if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/update&#x27;) &#123; return &#123; message: &#x27; 更新博客的接口&#x27; &#125; &#125; if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/delete&#x27;) &#123; return &#123; message: &#x27; 删除博客列表的接口&#x27; &#125; &#125;&#125;module.exports = handleBlogRoute 1234567891011121314151617181920212223242526272829303132333435363738394041// responseModel.js// 规范化响应数据class BaseModel &#123; constructor(data, message) &#123; if (typeof data == &#x27;string&#x27;) &#123; this.message = data data = null message = null &#125; if (data)&#123; this.data = data &#125; if (message)&#123; this.message = message &#125; &#125;&#125;// 这段代码定义了一个名为`SuccessModel`的类，继承自`BaseModel`。// `constructor`函数是类的构造函数，当通过`new SuccessModel()`创建对象时，会自动调用该函数进行对象的初始化。它接收两个参数`data`和`message`，代表数据和消息。// `super(data, message)`是调用父类`BaseModel`的构造函数，并将传入的`data`和`message`作为参数传递给父类的构造函数，以初始化继承的属性。// `this.errno = 0`是给当前对象添加一个新的属性`errno`，并为其赋值为0。// 综上，这段代码的作用是创建一个`SuccessModel`对象，通过调用父类的构造函数初始化继承的属性，然后为该对象添加一个`errno`属性并赋值为0。通常用于表示操作成功的返回模型。class SuccessModel extends BaseModel &#123; //成功接收模型 constructor(data, message)&#123; super(data, message) this.errno = 0 &#125;&#125;//失败接收模型class ErrorModel extends BaseModel&#123; constructor(data,message)&#123; super(data,message) this.errno = -1 &#125;&#125;module.exports = &#123; SuccessModel, ErrorModel&#125; 123456789101112131415161718192021222324// controllers/blog.jsconst getList = () =&gt; &#123; // 先定义假数据 return [ &#123; id: 1, title: &#x27;标题1&#x27;, content: &#x27;内容1&#x27;, author: &#x27;zhangsan&#x27;, createdAt: 1610555518935 &#125;, &#123; id: 2, title: &#x27;标题2&#x27;, content: &#x27;内容2&#x27;, author: &#x27; lisi &#x27;, createdAt: 1610555535044 &#125; ]&#125;module.exports = &#123; getList&#125; 处理异步代码req.on(data)指每次发送的数据；req.on(end)数据发送完成* 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 读取data中的json数据const fs = require(&#x27;fs&#x27;) // fs:用来读取文件const path = require(&#x27;path&#x27;)// promise 实现 读取文件内容function getFileContent(filename) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; // 数据文件的绝对路径 const fullFilename = path.resolve(__dirname, &#x27;data&#x27;, filename) // 在函数内部，使用path.resolve(__dirname, &#x27;data&#x27;, filename)的方式组合了一个完整的文件路径，__dirname代表当前脚本所在的目录，data是一个子目录，filename是要读取的文件名。通过这个方式，可以得到要读取文件的完整路径fullFilename。 fs.readFile(fullFilename, (err, data) =&gt; &#123; if (err) &#123; reject(err) return &#125; resolve( JSON.parse(data.toString()) //转为json对象 ); &#125;) &#125;) return promise&#125;getFileContent(&#x27;a.json&#x27;).then(aData=&gt;&#123; console.log(&#x27;aData&#x27;,aData); return getFileContent(aData.next) //相当于返回一个promise&#125;).then(bData=&gt;&#123; console.log(&#x27;bData&#x27;,bData) return getFileContent(bData.next)&#125;).then(cData=&gt;&#123; console.log(&#x27;cData&#x27;,cData);&#125;)// Promise常用来处理异步代码 如POST请求// if(req.method === &#x27;POST&#x27;)&#123;// let postData = &#x27;&#x27;// // 接收数据流// req.on(&#x27;data&#x27;,chunk=&gt;&#123;// postData += chunk.toString()// &#125;)// req.on(&#x27;end&#x27;,()=&gt;&#123;// console.log(&#x27;postData&#x27;,postData);// req.end(&#x27;数据接收完毕&#x27;)// &#125;)// &#125; 处理POST数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// app.jsconst handleBlogRoute = require(&#x27;./src/routes/blog&#x27;)const querystring = require(&#x27;querystring&#x27;)// 处理POST数据const getPostData = (req) =&gt; &#123; // req 接收请求参数 const promise = new Promise((resolve, reject) =&gt; &#123; // 判断是否为post请求 if (req.method !== &#x27;POST&#x27;) &#123; resolve(&#123;&#125;) return &#125; // 判断是否为json格式 if (req.headers[&#x27;content-type&#x27;] !== &#x27;application/json&#x27;) &#123; // 头部字段名(content-type)是不区分大小写的。 resolve(&#123;&#125;) return &#125; // 接收post数据 let postData = &#x27;&#x27; req.on(&#x27;data&#x27;, chunk =&gt; &#123; postData += chunk.toString() &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; if (!postData) &#123; resolve(&#123;&#125;) return &#125; resolve( JSON.parse(postData) ) &#125;) &#125;) return promise&#125;const serverHandler = (req, res) =&gt; &#123; // 设置响应格式 res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;) // 获取path const url = req.url // 将path挂在req对象上，方便访问 req.path = url.split(&#x27;?&#x27;)[0] // 解析 query req.query = querystring.parse(url.split(&#x27;?&#x27;)[1]) getPostData(req).then((postData) =&gt; &#123; req.body = postData // 博客相关路由 const blogData = handleBlogRoute(req, res) if (blogData) &#123; // 结束请求 返回响应 res.end( JSON.stringify(blogData) ) return; &#125; // 若没有匹配到任何blog的路由 // 设置状态码，覆盖返回类型 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;) res.write(&#x27;404 Not Found&#x27;) res.end() &#125;)&#125;module.exports = serverHandler 开发新建、更新、删除博客的路由1234567891011121314151617181920212223242526 // 新增博客路由if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/new&#x27;) &#123; const newBlogData = creatNewBlog(blogData) return &#123; message: &#x27; 新建博客的接口&#x27; &#125;&#125;// 更新博客路由if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/update&#x27;) &#123; // console.log(req.body); const updatadBlogData = updataBlog(id, blogData) if (updatadBlogData)&#123; return new SuccessModel(&#x27;更新博客成功&#x27;) &#125;else&#123; return new ErrorModel(&#x27;更新博客失败...&#x27;) &#125; &#125;// 删除博客路由if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/delete&#x27;) &#123; const deleteBlogData = deleteBlog(id) if (deleteBlogData)&#123; return new SuccessModel(&#x27;删除博客成功&#x27;) &#125;else&#123; return new ErrorModel(&#x27;删除博客失败...&#x27;) &#125; &#125; 用docker创建mysql 创建卷 默认情况下，MySQL 将其数据文件存储在该 /var/lib/myblog 目录中。因此，在部署之前，您需要设置一个 Docker 卷来持久化您的数据库。否则，当容器重新启动时，您的数据将丢失。 123docker volume create myblog# 检查volumedocker volume ls 运行一个 MySQL Docker 容器 1docker run -d --name=myblog -p 3306:3306 -v myblog:/var/lib/myblog -e MYSQL_ROOT_PASSWORD=123456 -e LANG=&quot;C.UTF-8&quot; mysql:5 -d 将以分离模式运行此容器，以便它在后台运行。 --name 将名称分配mysql-server给您的容器实例。如果不指定此项，Docker 将生成一个随机名称。 -p 将 MySQL 容器端口绑定3306到主机上的相同端口。您将能够 使用在您的主机上运行的MySQL 客户端 ( )连接到 127.0.0.1端口。3306``mysql -v 选项将容器卷 ( /var/lib/mysql)内的数据文件夹绑定到mysql-data您在上一步中创建的本地 Docker 卷 ( )。 -e 设置环境变量。在这种情况下，MySQL 根密码。 mysql 是我们用来创建容器的图像的名称。 docker 的 mysql 容器不能输入中文解决方法： 构建docker 容器时候增加一个变量 -e LANG&#x3D;C.UTF-8 持久修改-docker-compose.yml docker-compose.yml添加如下配置： 12345environment: TZ: &quot;Asia/Shanghai&quot; LANG: en_US.UTF-8 volumes: - /etc/localtime:/etc/localtime:ro https://blog.51cto.com/u_13849441/5073579?share_token=d9184312-14e6-4254-8094-13f81e74f74a 要永久修改需在创建镜像时在Dockerfile中设置。持久修改-Dockerfile在Dockerfile中添加一行 ENV LANG C.UTF-8 ，重新制作Mysql镜像 https://blog.csdn.net/wangshiqi666/article/details/130498331?share_token=e1936136-7190-4a79-a7f2-3c86dd1e1f03 12FROM mysql:8.0ENV LANG C.UTF-8 可以通过列出正在运行的容器来检查容器是否正在运行： 1docker ps 连接到 MySQL 容器 1docker exec -it myblog mysql -u root -p123456 --default-character-set=utf8mb4 停止、启动和重启 MySQL 容器 123docker stop myblogdocker start myblogdocker restart myblog 数据库操作 12345678910111213141516171819202122# 1.创建数据库CREATE DATABASE myblog;# 2.选择数据库USE 数据库名;USE myblog;# 3.创建表格CREATE TABLE 表格名 ( 列1 数据类型, 列2 数据类型, ..... 列N 数据类型);# 可将2 3步骤写为：CREATE TABLE myblog . blogs ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(50) NOT NULL, content LONGTEXT NOT NULL, author VARCHAR(20) NOT NULL, createdAt BIGINT(20) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; # 设置字符集为utf8-- 用两个--注释mysql语句 LONGTEXT：表示可存更多的数据 BIGINT()：表示更大的整数 1234# 4.向数据库中插入数据use myblog;-- show tables;insert into blogs(title,content,author,createdAt) values (&#x27;标题1&#x27;,&#x27;内容1&#x27;,&#x27;bing&#x27;,&#x27;1234567890123&#x27;); 登录MySQL数据库，通过show variables like &#39;character%&#39;; 查看编码格式 mysql 常见的数据表命令行操作1234561. **创建表：** CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50) NOT NULL, pwd VARCHAR(50) NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 12. 查看表结构：DESC &lt;表名&gt;; 123. 插入数据： INSERT INTO &lt;表名&gt; (&lt;列1&gt;, &lt;列2&gt;, ...) VALUES (&lt;值1&gt;, &lt;值2&gt;, ...);\t示例： INSERT INTO users (id, name, age) VALUES (1, &#x27;John&#x27;, 25); 1234564. 查询数据： SELECT &lt;列1&gt;, &lt;列2&gt;, ... FROM &lt;表名&gt; WHERE &lt;条件&gt;;\t示例：\tSELECT name, age FROM users WHERE id = 1; mysql&gt; select * from blogs where id=1; - 模糊查询： select * from blogs where title like &#x27;%模糊查询内容%&#x27;; - 根据id进行排序： order by id - 倒序： desc 125. 更新数据： UPDATE &lt;表名&gt; SET &lt;列1&gt; = &lt;新值1&gt;, &lt;列2&gt; = &lt;新值2&gt; WHERE &lt;条件&gt;;\t示例： UPDATE blogs set title = &#x27;标题&#x27; WHERE id = 1; 123456786. 删除\t- 删除数据： DELETE FROM &lt;表名&gt; WHERE &lt;条件&gt;; 示例： DELETE FROM blogs WHERE title = &#x27;标题2&#x27;;\t- 删除表： DROP TABLE &lt;表名&gt;; 示例： DROP TABLE users;\t- 软删除 - select * from blogs where state=&#x27;1&#x27;; -- 软删除 - update blogs set state=&#x27;1&#x27; where author=&#x27;zhangsan&#x27;; 123456787. ALTER 用法：\t- 添加字段 alter table + 表的名字 add + 字段名 + 字段类型 示例： alter table blogs add state int null default 1 after `createdAt`;\t- 删除字段 alter table + 表的名字 drop + 删除的字段名 示例： alter table blogs drop state;\t- 修改字段的数据类型 modify alter table 表名 modify 字段名 新数据类型; alter table users modify id INT PRIMARY KEY AUTO_INCREMENT; 128. 不等号 &lt;&gt;\t- select * from blogs where state&lt;&gt;&#x27;1&#x27;; 12349. 使用SHOW TABLES查询所有表的名称\t- SHOW TABLES;\t使用SELECT * FROM查询表数据\t- SHOW TABLES 表名; nodejs 连接 mysql 创建 mysql-demo 文件夹 ，cd到该路径，执行 npm init -y 进行初始化 安装mysql的工具，执行 npm install mysql 123456789101112131415161718192021222324252627// Node.js 连接 mysqlconst mysql = require(&#x27;mysql&#x27;)// 创建连接对象const connection = mysql.createConnection(&#123; host:&#x27;localhost&#x27;, user:&#x27;root&#x27;, password:&#x27;123456&#x27;, port:&#x27;3306&#x27;, //默认端口 database:&#x27;myblog&#x27;&#125;)// 开始连接connection.connect()// 执行sql语句const sql = `select * from blogs` // 反引号connection.query(sql,(err,result)=&gt;&#123; if (err)&#123; console.error(&#x27;error&#x27;,err); return &#125; console.log(result);&#125;)// 关闭连接connection.end() 封装执行 sql 语句的函数将配置参数写入config中，方便修改配置 123456789101112// src/config/db.js let MYSQL_CONFIG = &#123;&#125;MYSQL_CONFIG = &#123; host: &#x27;localhost&#x27;, user: &#x27;root&#x27;, password: &#x27;123456&#x27;, port: &#x27;3306&#x27;, //默认端口 database: &#x27;myblog&#x27;&#125;module.exports = &#123; MYSQL_CONFIG&#125; 采用promise操作 1234const sql = `select * from blogs` // 反引号execSQL(sql).then(result=&gt;&#123; console.log(&#x27;result&#x27;,result)&#125;) 修改js 1234567891011121314151617181920212223242526// src/db/mysql.js// Node.js 连接 mysqlconst mysql = require(&#x27;mysql&#x27;)const &#123; MYSQL_CONFIG &#125; = require(&#x27;../config/db&#x27;)// 创建连接对象const connection = mysql.createConnection(MYSQL_CONFIG)// 开始连接connection.connect()// 执行sql语句// promisefunction execSQL(sql) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; connection.query(sql, (err, result) =&gt; &#123; if (err) &#123; reject(err) return &#125; resolve(result) &#125;) &#125;) return promise&#125;module.exports = &#123; execSQL&#125; 博客列表接口对接mysqlcontrollers代码更改 123456789101112131415const &#123;execSQL&#125; = require(&#x27;../db/mysql&#x27;)// 获取博客列表数据const getBlogsList = (author, keyword) =&gt; &#123; let sql = `select * from blogs where 1=1` // 反引号 加 1=1 是为了防止author不存在时报错 if(author)&#123; sql+=` and author=&#x27;$&#123;author&#125;&#x27;` &#125; if(keyword)&#123; sql+=` and title like &#x27;%$&#123;keyword&#125;%&#x27;` &#125; return execSQL(sql)&#125; 修改处理路由的逻辑 123456789101112if (method === &#x27;GET&#x27; &amp;&amp; req.path === &#x27;/api/blog/list&#x27;) &#123; // /api/blog/list?author=zhangsan&amp;keyword=123 // new SuccessModel() const author = req.query.author || &#x27;&#x27; // 获取不到时为 &#x27;&#x27; const keyword = req.query.keyword || &#x27;&#x27; const listDataPromise = getBlogsList(author, keyword) //返回为promise类型 return listDataPromise.then(listData =&gt; &#123; // 最终返回promise return new SuccessModel(listData) &#125;)&#125; app.js中修改 123456789101112131415161718getPostData(req).then((postData) =&gt; &#123; req.body = postData // 博客相关路由 const blogDataPromise = handleBlogRoute(req, res) if (blogDataPromise) &#123; // 结束请求 返回响应 blogDataPromise.then(blogData =&gt; &#123; res.end( JSON.stringify(blogData) ) &#125;) return; &#125; // 若没有匹配到任何blog的路由 // 设置状态码，覆盖返回类型 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;) res.write(&#x27;404 Not Found&#x27;) res.end()&#125;) 博客详情和新建博客接口1234567891011121314// 创建博客const creatNewBlog = (blogData = &#123;&#125;) =&gt; &#123; // 给blogData设置一个空对象 // blogData: title content author createdAt // console.log(&#x27;blogData&#x27;, blogData); const title = blogData.title const content = blogData.content const author = blogData.author const createdAt = Date.now() //获取时间戳 const sql = `insert into blogs (title,content,author,createdAt) values (&#x27;$&#123;title&#125;&#x27; , &#x27;$&#123;content&#125;&#x27; , &#x27;$&#123;author&#125;&#x27; , $&#123;createdAt&#125;)` return execSQL(sql).then(insertedResult =&gt; &#123; console.log(&#x27;insertedResult&#x27;, insertedResult); return insertedResult.insertId &#125;)&#125; 12345678910111213// 新增博客路由if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/new&#x27;) &#123; // const newBlogData = creatNewBlog(blogData) // return &#123; // message: &#x27; 新建博客的接口&#x27; // &#125; const author = &#x27;bing&#x27; req.body.author = author const newBlogDataPromise = creatNewBlog(blogData) return newBlogDataPromise.then(newBlogData=&gt;&#123; return new SuccessModel(newBlogData) &#125;)&#125; 更新和删除博客routes&#x2F;blogs 12345678910111213141516171819202122232425// 更新博客路由if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/update&#x27;) &#123; const updatadBlogPrimose = updataBlog(id, blogData) // return updatadBlogPrimose.then(updatadBlogData=&gt;console.log(updataBlog)) return updatadBlogPrimose.then(updatadBlogData =&gt; &#123; if (updatadBlogData) &#123; return new SuccessModel(&#x27;更新博客成功&#x27;) &#125; else &#123; return new ErrorModel(&#x27;更新博客失败...&#x27;) &#125; &#125;)&#125;// 删除博客路由if (method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/api/blog/delete&#x27;) &#123; const author = &#x27;bing&#x27; const deleteBlogPromise = deleteBlog(id, author) return deleteBlogPromise.then(deleteBlogData =&gt; &#123; if (deleteBlogData) &#123; return new SuccessModel(&#x27;删除博客成功&#x27;) &#125; else &#123; return new ErrorModel(&#x27;删除博客失败...&#x27;) &#125; &#125;)&#125; controllers&#x2F;blogs 1234567891011121314151617181920212223242526// 更新博客const updataBlog = (id, blogData = &#123;&#125;) =&gt; &#123; const title = blogData.title const content = blogData.content const sql = `update blogs set title=&#x27;$&#123;title&#125;&#x27; , content=&#x27;$&#123;content&#125;&#x27; where id = $&#123;id&#125;` return execSQL(sql).then(upDateResult =&gt; &#123; // console.log(&#x27;upDateResult&#x27;,upDateResult); if (upDateResult.affectedRows &gt; 0) &#123; return true &#125; return false &#125;)&#125;// 删除博客const deleteBlog = (id, author) =&gt; &#123; const sql = `delete from blogs where id = $&#123;id&#125; and author = &#x27;$&#123;author&#125;&#x27;` return execSQL(sql).then(deleteResult =&gt; &#123; // console.log(blogData); if (deleteResult.affectedRows &gt; 0) &#123; return true &#125; return false &#125;)&#125; cookie 和 session 入门1234567891011121314151617181920// 登录 cookiereq.query = &#123;&#125;const cookieStr = req.headers.cookie || &#x27;&#x27;if (method === &#x27;GET&#x27; &amp;&amp; req.path === &#x27;/user/login&#x27;) &#123; //cookie: username=bing;age=15 if (!cookieStr) return return new Promise((resolve, reject) =&gt; &#123; cookieStr.split(&#x27;;&#x27;).forEach(item =&gt; &#123; if (!item) &#123; reject(&#123;&#125;) &#125; const arr = item.split(&#x27;=&#x27;) const key = arr[0].trim() // 去除空格 const val = arr[1].trim() req.query[key] = val &#125;) resolve(JSON.stringify(req.query)) // console.log(JSON.stringify(req.query)); &#125;) 服务端设置cookie path : 设置cookie的路径 expires : cookie有效期 1234567 function serCookieExpireTime() &#123; const date = new Date() date.setTime(date.getTime() + 10 * 1000) // 设置10s的有效期 return date.toGMTString() // 转格式 &#125;req.setHeader(&#x27;set-Cookie&#x27;, `username=xin;path=/;expires=&#x27;$&#123;serCookieExpireTime()&#125;&#x27;`)","tags":["node"],"categories":["博客"]},{"title":"Hello World","path":"/2023/07/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]